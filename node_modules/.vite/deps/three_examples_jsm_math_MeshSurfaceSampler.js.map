{
  "version": 3,
  "sources": ["../../three/examples/jsm/math/MeshSurfaceSampler.js"],
  "sourcesContent": ["import {\n\tTriangle,\n\tVector2,\n\tVector3\n} from 'three';\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - http://www.joesfer.com/?p=84\n * - https://stackoverflow.com/a/4322940/1314762\n */\n\nconst _face = new Triangle();\nconst _color = new Vector3();\nconst _uva = new Vector2(), _uvb = new Vector2(), _uvc = new Vector2();\n\nclass MeshSurfaceSampler {\n\n\tconstructor( mesh ) {\n\n\t\tthis.geometry = mesh.geometry;\n\t\tthis.randomFunction = Math.random;\n\n\t\tthis.indexAttribute = this.geometry.index;\n\t\tthis.positionAttribute = this.geometry.getAttribute( 'position' );\n\t\tthis.normalAttribute = this.geometry.getAttribute( 'normal' );\n\t\tthis.colorAttribute = this.geometry.getAttribute( 'color' );\n\t\tthis.uvAttribute = this.geometry.getAttribute( 'uv' );\n\t\tthis.weightAttribute = null;\n\n\t\tthis.distribution = null;\n\n\t}\n\n\tsetWeightAttribute( name ) {\n\n\t\tthis.weightAttribute = name ? this.geometry.getAttribute( name ) : null;\n\n\t\treturn this;\n\n\t}\n\n\tbuild() {\n\n\t\tconst indexAttribute = this.indexAttribute;\n\t\tconst positionAttribute = this.positionAttribute;\n\t\tconst weightAttribute = this.weightAttribute;\n\n\t\tconst totalFaces = indexAttribute ? ( indexAttribute.count / 3 ) : ( positionAttribute.count / 3 );\n\t\tconst faceWeights = new Float32Array( totalFaces );\n\n\t\t// Accumulate weights for each mesh face.\n\n\t\tfor ( let i = 0; i < totalFaces; i ++ ) {\n\n\t\t\tlet faceWeight = 1;\n\n\t\t\tlet i0 = 3 * i;\n\t\t\tlet i1 = 3 * i + 1;\n\t\t\tlet i2 = 3 * i + 2;\n\n\t\t\tif ( indexAttribute ) {\n\n\t\t\t\ti0 = indexAttribute.getX( i0 );\n\t\t\t\ti1 = indexAttribute.getX( i1 );\n\t\t\t\ti2 = indexAttribute.getX( i2 );\n\n\t\t\t}\n\n\t\t\tif ( weightAttribute ) {\n\n\t\t\t\tfaceWeight = weightAttribute.getX( i0 )\n\t\t\t\t\t+ weightAttribute.getX( i1 )\n\t\t\t\t\t+ weightAttribute.getX( i2 );\n\n\t\t\t}\n\n\t\t\t_face.a.fromBufferAttribute( positionAttribute, i0 );\n\t\t\t_face.b.fromBufferAttribute( positionAttribute, i1 );\n\t\t\t_face.c.fromBufferAttribute( positionAttribute, i2 );\n\t\t\tfaceWeight *= _face.getArea();\n\n\t\t\tfaceWeights[ i ] = faceWeight;\n\n\t\t}\n\n\t\t// Store cumulative total face weights in an array, where weight index\n\t\t// corresponds to face index.\n\n\t\tconst distribution = new Float32Array( totalFaces );\n\t\tlet cumulativeTotal = 0;\n\n\t\tfor ( let i = 0; i < totalFaces; i ++ ) {\n\n\t\t\tcumulativeTotal += faceWeights[ i ];\n\t\t\tdistribution[ i ] = cumulativeTotal;\n\n\t\t}\n\n\t\tthis.distribution = distribution;\n\t\treturn this;\n\n\t}\n\n\tsetRandomGenerator( randomFunction ) {\n\n\t\tthis.randomFunction = randomFunction;\n\t\treturn this;\n\n\t}\n\n\tsample( targetPosition, targetNormal, targetColor, targetUV ) {\n\n\t\tconst faceIndex = this.sampleFaceIndex();\n\t\treturn this.sampleFace( faceIndex, targetPosition, targetNormal, targetColor, targetUV );\n\n\t}\n\n\tsampleFaceIndex() {\n\n\t\tconst cumulativeTotal = this.distribution[ this.distribution.length - 1 ];\n\t\treturn this.binarySearch( this.randomFunction() * cumulativeTotal );\n\n\t}\n\n\tbinarySearch( x ) {\n\n\t\tconst dist = this.distribution;\n\t\tlet start = 0;\n\t\tlet end = dist.length - 1;\n\n\t\tlet index = - 1;\n\n\t\twhile ( start <= end ) {\n\n\t\t\tconst mid = Math.ceil( ( start + end ) / 2 );\n\n\t\t\tif ( mid === 0 || dist[ mid - 1 ] <= x && dist[ mid ] > x ) {\n\n\t\t\t\tindex = mid;\n\n\t\t\t\tbreak;\n\n\t\t\t} else if ( x < dist[ mid ] ) {\n\n\t\t\t\tend = mid - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstart = mid + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn index;\n\n\t}\n\n\tsampleFace( faceIndex, targetPosition, targetNormal, targetColor, targetUV ) {\n\n\t\tlet u = this.randomFunction();\n\t\tlet v = this.randomFunction();\n\n\t\tif ( u + v > 1 ) {\n\n\t\t\tu = 1 - u;\n\t\t\tv = 1 - v;\n\n\t\t}\n\n\t\t// get the vertex attribute indices\n\t\tconst indexAttribute = this.indexAttribute;\n\t\tlet i0 = faceIndex * 3;\n\t\tlet i1 = faceIndex * 3 + 1;\n\t\tlet i2 = faceIndex * 3 + 2;\n\t\tif ( indexAttribute ) {\n\n\t\t\ti0 = indexAttribute.getX( i0 );\n\t\t\ti1 = indexAttribute.getX( i1 );\n\t\t\ti2 = indexAttribute.getX( i2 );\n\n\t\t}\n\n\t\t_face.a.fromBufferAttribute( this.positionAttribute, i0 );\n\t\t_face.b.fromBufferAttribute( this.positionAttribute, i1 );\n\t\t_face.c.fromBufferAttribute( this.positionAttribute, i2 );\n\n\t\ttargetPosition\n\t\t\t.set( 0, 0, 0 )\n\t\t\t.addScaledVector( _face.a, u )\n\t\t\t.addScaledVector( _face.b, v )\n\t\t\t.addScaledVector( _face.c, 1 - ( u + v ) );\n\n\t\tif ( targetNormal !== undefined ) {\n\n\t\t\tif ( this.normalAttribute !== undefined ) {\n\n\t\t\t\t_face.a.fromBufferAttribute( this.normalAttribute, i0 );\n\t\t\t\t_face.b.fromBufferAttribute( this.normalAttribute, i1 );\n\t\t\t\t_face.c.fromBufferAttribute( this.normalAttribute, i2 );\n\t\t\t\ttargetNormal.set( 0, 0, 0 ).addScaledVector( _face.a, u ).addScaledVector( _face.b, v ).addScaledVector( _face.c, 1 - ( u + v ) ).normalize();\n\n\t\t\t} else {\n\n\t\t\t\t_face.getNormal( targetNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( targetColor !== undefined && this.colorAttribute !== undefined ) {\n\n\t\t\t_face.a.fromBufferAttribute( this.colorAttribute, i0 );\n\t\t\t_face.b.fromBufferAttribute( this.colorAttribute, i1 );\n\t\t\t_face.c.fromBufferAttribute( this.colorAttribute, i2 );\n\n\t\t\t_color\n\t\t\t\t.set( 0, 0, 0 )\n\t\t\t\t.addScaledVector( _face.a, u )\n\t\t\t\t.addScaledVector( _face.b, v )\n\t\t\t\t.addScaledVector( _face.c, 1 - ( u + v ) );\n\n\t\t\ttargetColor.r = _color.x;\n\t\t\ttargetColor.g = _color.y;\n\t\t\ttargetColor.b = _color.z;\n\n\t\t}\n\n\t\tif ( targetUV !== undefined && this.uvAttribute !== undefined ) {\n\n\t\t\t_uva.fromBufferAttribute( this.uvAttribute, i0 );\n\t\t\t_uvb.fromBufferAttribute( this.uvAttribute, i1 );\n\t\t\t_uvc.fromBufferAttribute( this.uvAttribute, i2 );\n\t\t\ttargetUV.set( 0, 0 ).addScaledVector( _uva, u ).addScaledVector( _uvb, v ).addScaledVector( _uvc, 1 - ( u + v ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { MeshSurfaceSampler };\n"],
  "mappings": "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",
  "names": []
}
