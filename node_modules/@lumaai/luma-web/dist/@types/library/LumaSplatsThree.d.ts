/**
 * TODO
 * - Looping
 * - Transparency/refraction example
 * 	- Near clipping plane on globe splats that clips front sphere
 * 	- Configurable shader near fade
 * - CubeTexture upload breaks sort??
 * 	- captureCubeMap() sorts from its perspective
 * 	- solve by duplicating splats, only splitting index buffers and sorting from cube camera perspective
 * - Experiment with fake DOF
 * - Basic crop! Just trivial sphere to start
 * - Three.js demos
 * 	- Annotation
 *  - Environment map probe?
 *  - Glass portals
 * 	- GLSL editor
 * - Soap bubbles
 * => Github Repo
 *
 * - clone & copy support
 * - Remove use of v3 and m4
 * - Optimize bounding calculation
 * - Fix splats getting cut off randomly
 * - Test SH textures!!
 * - Try reducing splats, understand shells
 * - Add clipping sphere and planes
 * - Shader code inserts for user control over splats and to enable some exciting demos
 * - three.js interaction demo
 * - renderDepth support, get click location?
 * 	- maybe use separate material for renderDepth
 * - Improve depth buffer: we can have depth vary over quad
 * - Can we handle semantics by separate index buffers rather than in shader?
 */
import { Box3, Camera, CubeTexture, InstancedBufferGeometry, Mesh, ShaderMaterial, Sphere, Vector3, WebGLRenderer } from "three";
import { LumaSplatsLoader } from "./LumaSplatsLoader";
import { LumaShaderHooks, LumaSplatsOptions, LumaSplatsSemantics, LumaSplatsWebGL } from "./LumaSplatsWebGL";
export type LumaSplatsSource = {
    readonly captureUrl?: string | null;
    readonly uuid?: string | null;
    readonly src?: string | null;
    readonly fetchOptions?: RequestInit;
} | string;
export type LumaSplatsThreeOptions = LumaSplatsOptions & {
    /**
     * Luma splat file
     */
    source?: LumaSplatsSource;
    /**
     * Explicitly provide a loader, take precedence over `source`
     */
    loader?: LumaSplatsLoader;
    /**
     * Controls integration with three.js shader system, including tone mapping, fog and color spaces
     * Set this to `false` if you do not use these features and you want to optimize for performance
     * @default true
     **/
    enableThreeShaderIntegration?: boolean;
    /**
     * Called before
     */
    onBeforeRender?: (renderer: WebGLRenderer, scene: Scene, camera: Camera, splats: LumaSplatsThree) => void;
};
export declare class LumaSplatsThree extends Mesh<InstancedBufferGeometry, LumaMaterial> {
    boundingBox: Box3;
    boundingSphere: Sphere;
    semanticsMask: LumaSplatsSemantics;
    /** Softly fade in the model as data streams in (default `true`) */
    loadingAnimationEnabled: boolean;
    /** Reveal the model from particles (default `false`) */
    particleRevealEnabled: boolean;
    /** Disable draw call but still perform onBeforeRender and other updates */
    preventDraw: boolean;
    /** Disable sorting */
    preventSort: boolean;
    skybox: Mesh;
    skyboxTexture: CubeTexture;
    private _source;
    get source(): LumaSplatsSource | null;
    set source(value: LumaSplatsSource | null);
    /**
     * Controls integration with three.js shader system, including tone mapping, fog and color spaces
     * Set this to `false` if you do not use these features and you want to optimize for performance
     * @default true
     **/
    get enableThreeShaderIntegration(): boolean;
    set enableThreeShaderIntegration(enabled: boolean);
    /**
     * The splat file contains an ideal viewing position, this callback is executed when this information has been downloaded
     */
    onInitialCameraTransform: ((transform: Matrix4) => void) | null;
    /**
     * Called when the splat is fully loaded
     */
    onLoad: ((splats: LumaSplatsThree) => void) | null;
    /**
     * Called when the splat is loading
     */
    onProgress: ((e: {
        progress: number;
    }) => void) | null;
    private gaussTextures;
    private shTexture;
    private semanticsTexture;
    private splatIndexAttribute;
    private lumaSplatsWebGL;
    private _materialThreeShaderIntegration;
    private _materialRaw;
    private _skyboxMaterialThreeShaderIntegration;
    private _skyboxMaterialRaw;
    private addedSkybox;
    private placeholderGeometry;
    private instancedQuadGeometry;
    constructor(optionsOrUrl?: LumaSplatsThreeOptions | string);
    /**
     * Initializes and synchronizes GPU objects before rendering
     * This is normally done in this.onBeforeRender however as geometry cannot be changed during render in three.js, it's sometimes helpful to call this before rendering to ensure the geometry is ready
     * @param renderer
     */
    prepareGLObjects(renderer: WebGLRenderer): void;
    setShaderHooks(shaderHooks: LumaShaderHooks): void;
    captureCubemap(renderer: WebGLRenderer, position?: Vector3, near?: number, far?: number, resolution?: number): Promise<CubeTexture>;
    dispose: () => void;
    private _loaderEventListeners;
    private updateLoader;
    private onPointsUpdate;
}
import { Matrix4, Scene, Texture } from "three";
interface LumaMaterial extends ShaderMaterial {
    setShaderHooks: (shaderHooks: LumaShaderHooks) => void;
    updateUniformsAndDefines: (lumaSplatsThree: LumaSplatsThree, lumaSplatsWebGL: LumaSplatsWebGL, renderer: WebGLRenderer, scene: Scene, view: {
        modelViewMatrix: Matrix4;
        projectionMatrix: Matrix4;
        viewPosition: Vector3;
        far: number;
    }, textures: {
        gaussTexture0: Texture;
        gaussTexture1: Texture;
        shTexture: Texture;
        semanticsTexture: Texture;
        skyboxTexture: Texture;
    }) => void;
}
export {};
