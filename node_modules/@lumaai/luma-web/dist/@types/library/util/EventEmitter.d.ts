export declare namespace EventEmitter {
    type Emitted<T> = T extends Event ? T & {
        propagationStopped?: boolean;
        _stopPropagation?: () => void;
    } : T;
    type Listener = ReturnType<EventEmitter['addListener']>;
}
/**
 * Event emitter with a notion of explicit ordering via priority
 */
export declare class EventEmitter<Payload = undefined, E = EventEmitter.Emitted<Payload>> {
    private listeners;
    addListener(listener: (event: E) => void, priority?: number): {
        priority: number;
        listener: (event: E) => void;
        remove: () => void;
    };
    removeListener(listener: (event: E) => void): void;
    once(listener: (event: E) => void, priority?: number): {
        priority: number;
        listener: (event: E) => void;
        remove: () => void;
    };
    /**
     * Dispatch an event by providing a payload
     * The underlying event object will be created and populated with the payload
     *
     * @param maxPriority If provided, only listeners with a priority equal or lower than this will be called
     */
    dispatch(payload: Payload, maxPriority?: number): void;
    /**
     * Dispatch an event with an existing event object
     *
     * This is useful if you want to forward an event from another source like a DOM event
     */
    dispatchWithExistingEvent(payload: Payload, maxPriority?: number): void;
    hasListeners(): boolean;
    private sortPriorityDescending;
    private patchPayload;
}
