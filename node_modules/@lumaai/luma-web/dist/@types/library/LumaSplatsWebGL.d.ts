import { LumaSplatsLoader } from "./LumaSplatsLoader.js";
import { Shader } from './util/Shader.js';
import { EventEmitter } from "./util/EventEmitter.js";
export type LumaSplatsOptions = {
    /** Softly fade in the model as data streams in (default `true`) */
    loadingAnimationEnabled?: boolean;
    /** Reveal the model from particles (default `false`) */
    particleRevealEnabled?: boolean;
};
export declare enum LumaSplatsSemantics {
    BACKGROUND = 1,
    FOREGROUND = 2,
    ALL = 255
}
export type UpdateTexturePayload<T> = {
    target: number;
    width: number;
    height: number;
    channels: number;
    currentHeight: number;
    data: T;
    internalFormat: number;
    format: number;
    type: number;
    unpackAlignment: number;
    minMagFilter: number;
    complete: boolean;
};
export declare class LumaSplatsWebGL {
    loader: LumaSplatsLoader;
    semanticsMask: LumaSplatsSemantics;
    /** True when a spherical harmonics texture has been uploaded */
    hasSphericalHarmonicsTexture: boolean;
    /** True when a semantics texture has been uploaded */
    hasSemanticsTexture: boolean;
    /** True when a skybox texture has been uploaded */
    hasSkyboxTexture: boolean;
    maxSortAge: number;
    sortAge: number;
    indicesNeedUpload: boolean;
    gaussTextureUpdatePayloads: [UpdateTexturePayload<Uint32Array> | null, UpdateTexturePayload<Uint32Array> | null];
    gaussTextureUploadedHeight: number[];
    shTextureUpdatePayload: UpdateTexturePayload<Uint16Array> | null;
    semanticsTextureUpdatePayload: UpdateTexturePayload<Uint8Array> | null;
    skyboxTextureUpdatePayload: Array<UpdateTexturePayload<HTMLCanvasElement>>;
    partialIndices: Uint32Array;
    numVisible: number;
    sortEnd: number;
    get numSplats(): number;
    needsSort: boolean;
    enableEnd: boolean;
    worker: Worker;
    workerBusy: boolean;
    loadingAnimation: {
        enabled: boolean;
        particleRevealEnabled: boolean;
        particleSolidDelay_ms: number;
        particleRevealSpeed: number;
        particleRevealOffset_ms: number;
        startTime_ms: number;
    };
    shaderParams: {
        loadR1: number;
        loadR2: number;
        revealR1: number;
        revealR2: number;
        solidR1: number;
        solidR2: number;
        /** 0=normal view, 1=ellipses, 2=opacity */
        debugView: number;
        /** controls splat size for debug */
        tweakScale: number;
    };
    events: {
        onLoad: EventEmitter<LumaSplatsWebGL, LumaSplatsWebGL>;
        onWorkerError: EventEmitter<string, string>;
        onRequestRender: EventEmitter<void, void>;
    };
    glObjects: {
        gaussTextures: [
            WebGLTexture,
            WebGLTexture
        ];
        shTexture: WebGLTexture;
        semanticsTexture: WebGLTexture;
        indexBuffer1: WebGLBuffer;
        indexBuffer2: WebGLBuffer;
        quadVertices: WebGLBuffer;
        skyboxTexture: WebGLTexture;
        skyboxVertices: WebGLBuffer;
        dispose: () => void;
    } | null;
    /**
     * {
     * 		[shader-id]: {
     * 			[flags]: Shader
     * 		}
     * }
     **/
    compiledShaders: Map<string, Map<number, Shader>>;
    private lastEye;
    private lastDir;
    private numWorkerPoints;
    private lastWorkerPoints;
    private loaderMetaReady;
    private shaderHooks;
    private workerReady;
    private resolveWorkerReady;
    constructor(loader: LumaSplatsLoader, options: LumaSplatsOptions);
    /**
     * Called before rendering, it allocates and synchronizes GPU resources
     */
    syncGpuResources(gl: WebGL2RenderingContext): boolean;
    drawSkybox(gl: WebGL2RenderingContext, camera: {
        viewMatrix: Float32Array;
        projectionMatrix: Float32Array;
    }): void;
    draw(gl: WebGL2RenderingContext, renderDepth: boolean, viewportWidth: number, viewportHeight: number, camera: {
        position: Float32Array;
        direction: Float32Array;
        viewMatrix: Float32Array;
        projectionMatrix: Float32Array;
        far: number;
    }): void;
    requestSort(eye: ArrayLike<number>, dir: ArrayLike<number>): boolean;
    /**
     * Queue a sort operation, differs from requestSort in that it does not skip the sort if not needed.
     */
    queueSort(eye: ArrayLike<number>, dir: ArrayLike<number>, onSortComplete?: () => void): void;
    tickAnimation(): void;
    setShaderHooks(shaderHooks: LumaShaderHooks): void;
    dispose(): void;
    private initWorker;
    private updateWorkerPoints;
    private cameraChanged;
    protected onWorkerMessage(evt: MessageEvent): void;
    /**
     * Called by Loader when new chunk of data arrived during loading.
     */
    private partialUpdate;
    private syncQueuedGpuData;
    private uploadTexture;
    private replaceGLPixelStoreParametersForPayload;
    private getGLPixelStoreParameters;
    private setGLPixelStoreParameters;
    private setGLTexParameters;
    private initGLObjects;
    private createSkyboxCube;
    /**
     * Returns a shader program variant for the given options, or compiles a new one if it doesn't exist
     */
    private getShader;
    /**
     * Compile a shader program variant for the given options
     */
    private compileShader;
    private getShaderDefines;
    private queueUpdateIndices;
    private queueUpdateGaussTexture;
    private queueUpdateSHTexture;
    private queueUpdateSemanticsTexture;
    private queueUpdateSkyboxTexture;
    private convertSemanticsToTiledTexture;
    private tiledCoords;
    /**
     * Animate reveal and point-to-solid loading effects.
     */
    private tickLoadingAnimation;
    /**
     * Animate smoothly expanding loading boundary.
     */
    private tickSoftLoadingBoundary;
    private handleQuirks;
}
export type LumaShaderHooks = {
    /** Hooks added to the vertex shader */
    vertexShaderHooks?: {
        additionalUniforms?: {
            [name: string]: [UniformTypeGLSL, {
                value: any;
            }];
        };
        /** Inject into global space (for example, to add varying) */
        additionalGlobals?: string;
        /**
         * Example `(vec3 splatPosition, uint layersBitmask) { return mat4(1.); }`
         * @param {vec3} splatPosition, object-space
         * @param {uint} layersBitmask, bit mask of layers, where bit 0 is background and bit 1 is foreground
         * @returns {mat4} per-splat local transform
         */
        getSplatTransform?: string;
        /**
         * Executed at the end of the main function after gl_Position is set
         *
         * Example `() {
         *  vPosition = gl_Position;
         * }`
         * @returns {void}
         */
        onMainEnd?: string;
        /**
         * Example `(vec4 splatColor, vec3 splatPosition) { return pow(splatColor.rgb, vec3(2.2), splatColor.a); }`
         * Use `gl_Position` is available
         * @param {vec4} splatColor, default splat color
         * @param {vec3} splatPosition, object-space
         * @param {uint} layersBitmask, bit mask of layers, where bit 0 is background and bit 1 is foreground
         * @returns {vec4} updated splat color
         */
        getSplatColor?: string;
    };
    /** Hooks added to the fragment shader */
    fragmentShaderHooks?: {
        additionalUniforms?: {
            [name: string]: [UniformTypeGLSL, {
                value: any;
            }];
        };
        /** Inject into global space (for example, to add varying) */
        additionalGlobals?: string;
        /**
         * Example `(vec4 fragColor) { return tonemap(fragColor); }`
         * @param {vec4} fragColor, default fragment color
         * @returns {vec4} updated fragment color
         */
        getFragmentColor?: string;
    };
};
type UniformTypeGLSL = 'float' | 'int' | 'bool' | 'vec2' | 'vec3' | 'vec4' | 'ivec2' | 'ivec3' | 'ivec4' | 'bvec2' | 'bvec3' | 'bvec4' | 'mat2' | 'mat3' | 'mat4' | 'mat2x2' | 'mat2x3' | 'mat2x4' | 'mat3x2' | 'mat3x3' | 'mat3x4' | 'mat4x2' | 'mat4x3' | 'mat4x4' | 'sampler2D' | 'sampler3D' | 'samplerCube' | 'sampler2DShadow' | 'samplerCubeShadow' | 'isampler2D' | 'isampler3D' | 'isamplerCube' | 'usampler2D' | 'usampler3D' | 'usamplerCube' | 'sampler2DArray' | 'sampler2DArrayShadow' | 'isampler2DArray' | 'usampler2DArray' | 'sampler3D' | 'isampler3D' | 'usampler3D';
export declare const splatVertexShader: string;
export declare const splatFragmentShader: string;
export declare const skyboxVertexShader: string;
export declare const skyboxFragmentShader: string;
export declare const skyboxVertices: Float32Array;
export declare function getShaderCodeWithHooks(vertexShader: string, fragmentShader: string, shaderHooks?: LumaShaderHooks | null): {
    vertexShader: string;
    fragmentShader: string;
};
export {};
