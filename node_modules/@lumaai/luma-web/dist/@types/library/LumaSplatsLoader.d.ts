/// <reference path="../../../misc/inline-worker-plugin.d.ts" />
export class LumaSplatsLoader {
    /**
     * @param {string | {
     *  captureUrl?: string | null,
     *  src?: string | null,
     *  uuid?: string | null,
     *  artifacts?: object | null,
     *  fetchOptions?: RequestInit, // optional fetch request options
     * }} sourceOptions - either the uuid of the capture or the capture artifacts
     * @param {boolean} streaming - if true, the loader will download data
     */
    constructor(sourceOptions: string | {
        captureUrl?: string | null;
        src?: string | null;
        uuid?: string | null;
        artifacts?: object | null;
        fetchOptions?: RequestInit;
    }, streaming?: boolean);
    dataset: {
        captureUrl?: string | null | undefined;
        src?: string | null | undefined;
        uuid?: string | null | undefined;
        artifacts?: object | null | undefined;
        fetchOptions?: RequestInit | undefined;
    };
    streaming: boolean;
    fetchOptions: RequestInit | undefined;
    metaVersion: number;
    numSplats: number;
    totalSplats: number;
    totalBytes: number;
    currentBytes: number;
    initialPose: Float32Array;
    scaleToWorld: number;
    /** @type {Array<Float32Array>} */
    animFrames: Array<Float32Array>;
    animFps: number;
    cpuPoints: Uint16Array;
    sceneCenter: number[];
    radiusList: Float32Array | null;
    radiusStep: number;
    minRadius: number;
    loadedRadius: number;
    isComplete: boolean;
    antialias: number;
    haveSH: boolean;
    haveSemantics: boolean;
    haveSkybox: boolean;
    skybox: {
        type: string;
        distance: number;
        origin: number[];
    };
    events: {
        /** @type {EventEmitter<void>} */
        partialUpdate: EventEmitter<void>;
        /** @type {EventEmitter<{bytesReady: number, totalBytes: number, progress: number}>} */
        progress: EventEmitter<{
            bytesReady: number;
            totalBytes: number;
            progress: number;
        }>;
        /** @type {EventEmitter<void>} */
        showProgress: EventEmitter<void>;
        /** @type {EventEmitter<void>} */
        hideProgress: EventEmitter<void>;
        /** @type {EventEmitter<LoaderTexturePayload<Uint32Array>>} */
        updateGauss1Texture: EventEmitter<LoaderTexturePayload<Uint32Array>>;
        /** @type {EventEmitter<LoaderTexturePayload<Uint32Array>>} */
        updateGauss2Texture: EventEmitter<LoaderTexturePayload<Uint32Array>>;
        /** @type {EventEmitter<LoaderTexturePayload<Uint16Array>>} */
        updateSHTexture: EventEmitter<LoaderTexturePayload<Uint16Array>>;
        /** @type {EventEmitter<LoaderTexturePayload<HTMLCanvasElement>>} */
        updateSkyboxTexture: EventEmitter<LoaderTexturePayload<HTMLCanvasElement>>;
        /** @type {EventEmitter<{start: number, end: number, cpuPoints: Uint16Array}>} */
        updateCpuPoints: EventEmitter<{
            start: number;
            end: number;
            cpuPoints: Uint16Array;
        }>;
        /** @type {EventEmitter<LumaSplatsLoader>} */
        complete: EventEmitter<LumaSplatsLoader>;
    };
    blocksDowloaded: number;
    gauss1Data: Uint32Array | null;
    gauss2Data: Uint32Array | null;
    gauss1Count: number;
    gauss2Count: number;
    gauss1Height: number;
    gauss2Height: number;
    cpuPtsCount: number;
    bytesReady: number;
    /** @type {Promise<{ artifacts: Awaited< ReturnType<LumaSplatsLoader['getArtifacts']> > } & Awaited<ReturnType<LumaSplatsLoader['downloadMeta']>> & Awaited<ReturnType<LumaSplatsLoader['downloadMeta2']>> >} */
    metaReady: Promise<{
        artifacts: Awaited<ReturnType<LumaSplatsLoader['getArtifacts']>>;
    } & Awaited<ReturnType<LumaSplatsLoader['downloadMeta']>> & Awaited<ReturnType<LumaSplatsLoader['downloadMeta2']>>>;
    /** @type {Promise<void>} */
    allReady: Promise<void>;
    /** @type {Promise<LoaderTexturePayload<Uint32Array>>} */
    coreBinReady: Promise<LoaderTexturePayload<Uint32Array>>;
    /** @type {Promise<LoaderTexturePayload<Uint32Array>>} */
    gauss1Ready: Promise<LoaderTexturePayload<Uint32Array>>;
    /** @type {Promise<LoaderTexturePayload<Uint32Array>>} */
    gauss2Ready: Promise<LoaderTexturePayload<Uint32Array>>;
    /** @type {Promise<LoaderTexturePayload<Uint16Array> | null>} */
    shReady: Promise<LoaderTexturePayload<Uint16Array> | null>;
    /** @type {Promise<ArrayBuffer | null>} */
    semanticsReady: Promise<ArrayBuffer | null>;
    /** @type {Promise<Array<LoaderTexturePayload<HTMLCanvasElement>> | null>} */
    skyboxReady: Promise<Array<LoaderTexturePayload<HTMLCanvasElement>> | null>;
    sceneRadius(): number;
    /**
     * @param {number} byteLength
     */
    addProgress(byteLength: number): void;
    showProgress(): void;
    hideProgress(): void;
    /**
     * Convert artifact array to object.
     * @param {Array<{url: string, type: string}>} renderRunArray
     * @returns {Object}
     */
    convertArtifactArray(renderRunArray: Array<{
        url: string;
        type: string;
    }>): Object;
    /**
     * @returns {Promise<{
     *  gs_web_webmeta?: string,
     *  gs_web_meta?: string,
     *  gs_web_gauss1?: string,
     *  gs_web_gauss2?: string,
     *  gs_web_sh?: string,
     *  gs_compressed_meta?: string,
     *  gs_compressed?: string,
     *  with_background_gs_camera_params?: string,
     *  semantics?: string,
     *  skybox?: string,
     *  skybox_meta?: string,
     * }>}
     */
    getArtifacts(): Promise<{
        gs_web_webmeta?: string;
        gs_web_meta?: string;
        gs_web_gauss1?: string;
        gs_web_gauss2?: string;
        gs_web_sh?: string;
        gs_compressed_meta?: string;
        gs_compressed?: string;
        with_background_gs_camera_params?: string;
        semantics?: string;
        skybox?: string;
        skybox_meta?: string;
    }>;
    /**
     * Downloads all metadata files, then all data files.
     */
    downloadAllFiles(): void;
    coreReady: Promise<void | null> | undefined;
    /**
     * Downloads a file, returns a Uint8Array with the content upon completion.
     *
     * 'partialCallback', if defined, gets called with partial buffer every time
     * at least 'updateBytes' is received.
     *
     * @param {string} url
     * @param {(function(Uint8Array, boolean): void) | undefined} partialCallback
     * @param {number} updateBytes
     * @returns {Promise<Uint8Array>}
     */
    fetchFile(url: string, partialCallback?: ((arg0: Uint8Array, arg1: boolean) => void) | undefined, updateBytes?: number): Promise<Uint8Array>;
    /**
     * Interprets 'data' as JSON text, parses it into object.
     * @param {Uint8Array} data
     * @returns {Object}
     */
    parseJSON(data: Uint8Array): Object;
    /** @param {string} url */
    downloadMeta(url: string): Promise<{
        metaVersion: number;
        totalSplats: number;
        totalBytes: number;
        sceneCenter: number[];
        radiusList: Float32Array;
        radiusStep: number;
        minRadius: number;
        antialias: number;
        haveSH: boolean;
        scaleToWorld: number;
        initialPose: Float32Array;
    }>;
    /**
     * Download and parse the 'gs_web_meta' artifact, used in v1 format to get scale_to_world and initial pose.
     * @param {string} url
     */
    downloadMeta2(url: string): {};
    /**
     * Download and parse the 'with_background_gs_camera_params', to get camera animation frames.
     * @param {string} url
     */
    downloadMeta3(url: string): Promise<void | {
        animFrames: Float32Array[];
        animFps: number;
    }>;
    /**
     * @param {Uint32Array} data
     * @param {number} texelSize
     */
    partialSizes(data: Uint32Array, texelSize: number): number[];
    /** @param {string} url */
    downloadCoreBin(url: string): Promise<void>;
    /**
     * Dispatch decoded texture blocks for GPU upload.
     * @param {number} size - number of decoded Gaussians
     * @param {Uint32Array} tex1 - first (2-channel) texture data
     * @param {Uint32Array} tex2 - second (4-channel) texture data
     * @param {Uint16Array} xyz - splat centers as 3x half-floats
     */
    updateCoreBlock(size: number, tex1: Uint32Array, tex2: Uint32Array, xyz: Uint16Array): void;
    /** @param {string} url */
    downloadGauss1(url: string): Promise<LoaderTexturePayload<Uint32Array>>;
    /** @param {string} url */
    downloadGauss2(url: string): Promise<LoaderTexturePayload<Uint32Array>>;
    partialUpdate(): void;
    /** @param {string} url */
    downloadSHTexture(url: string): Promise<LoaderTexturePayload<Uint16Array>>;
    /**
     * @param {{
     *  skybox: string,
     *  skybox_meta: string,
     * }} artifacts
     */
    downloadSkybox(artifacts: {
        skybox: string;
        skybox_meta: string;
    }): Promise<LoaderTexturePayload<HTMLCanvasElement>[]>;
    /**
     * @param {Uint8Array} data
     * @param {number} width
     * @param {number} count
     * @returns {void}
     */
    extractCpuPoints(data: Uint8Array, width: number, count: number): void;
    /**
     * Start the decoding worker.
     */
    initWorker(): void;
    worker: DecoderWorker | undefined;
    /**
     * Send one core.bin block for decoding
     * @param {Uint8Array} block
     * @param {number} maxSize - max number of gaussians in the encoded block
     * @param {number} seed - obfuscation seed
     */
    decodeBlock(block: Uint8Array, maxSize: number, seed: number): void;
    /**
     * Receives decoded blocks, and worker events.
     * @param {MessageEvent} evt
     */
    onWorkerMessage(evt: MessageEvent): void;
}
export type LoaderTexturePayload<T> = {
    target: number;
    width: number;
    height: number;
    channels: number;
    currentHeight: number;
    data: T;
    internalFormat: number;
    format: number;
    type: number;
    unpackAlignment: number;
    minMagFilter: number;
    complete: boolean;
};
import { EventEmitter } from './util/EventEmitter.js';
import DecoderWorker from 'inline-worker!./decoder.worker.js';
